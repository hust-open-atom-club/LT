# Linux 内核中的分页机制

本文件提供对 Linux 内核中 **分页（paging）** 机制的深入解释，尤其聚焦于 x86_64 架构下的实现。

---

## 简介

分页是内存管理中的基础机制，它实现了 **线性（虚拟）地址** 到 **物理地址** 的转换。这对内核的运行至关重要，尤其是在初始化阶段。在深入理解内核初始化之前，掌握分页的基本概念是非常重要的，因为它是现代操作系统内存管理的核心。

---

## 启用分页机制

要启用 **IA-32e 分页**（64 位模式），必须在特定 CPU 寄存器中设置以下位：

- **CR0** 寄存器中的 `CR0.PG` 位
- **CR4** 寄存器中的 `CR4.PAE` 位
- **IA32_EFER** 模型特定寄存器中的 `IA32_EFER.LME` 位

这些设置通常在内核早期的启动代码中完成，例如在 `head_64.S` 中。

示例代码：
```assembly
movl	$(X86_CR0_PG | X86_CR0_PE), %eax
movl	%eax, %cr0

movl	$MSR_EFER, %ecx
rdmsr
btsl	$_EFER_LME, %eax
wrmsr
```

---

## 分页结构

分页机制使用 **分层结构** 来实现虚拟地址到物理地址的转换。在 x86_64 架构下，Linux 内核采用 **四级分页机制**：

1. **页全局目录（PML4）**
2. **页上层目录（PUD）**
3. **页中间目录（PMD）**
4. **页表项（PTE）**

每一级包含 **512 个条目**，每个结构大小为 **4KB**。顶层结构的地址由 **CR3** 寄存器指向。

### CR3 寄存器格式

```
63                  52 51                                                        32
 --------------------------------------------------------------------------------
|                     |                                                          |
|    保留（必须为 0） |            顶层结构的地址                              |
|                     |                                                          |
 --------------------------------------------------------------------------------
31                                  12 11            5     4     3 2             0
 --------------------------------------------------------------------------------
|                                     |               |  P  |  P  |              |
|  顶层结构的地址                    |   保留        |  C  |  W  |    保留      |
|                                     |               |  D  |  T  |              |
 --------------------------------------------------------------------------------
```

- **位 63:52** - 保留（必须为 0）
- **位 51:12** - 顶层结构的物理地址
- **位 11:5** - 保留
- **位 4:3** - PWT（页级写通），PCD（页级缓存禁用）
- **位 2:0** - 忽略

---

## 虚拟地址转换

使用 64 位虚拟地址，但只有 **低 48 位** 是有效的。地址被划分为多个部分：

- **位 47:39** - 用于索引 PML4
- **位 38:30** - 用于索引 PUD
- **位 29:21** - 用于索引 PMD
- **位 20:12** - 用于索引 PTE
- **位 11:0** - 页内偏移量

### 示例：地址 `0xffffffff81000000`

二进制表示：
```
1111111111111111 111111111 111111110 000001000 000000000 000000000000
      63:48        47:39     38:30     29:21     20:12      11:0
```

该地址属于 **内核的文本段（text section）**，从物理地址 0 映射而来。

---

## 内核虚拟内存映射

x86_64 架构下的虚拟地址空间分为：

- **用户空间**（`0x0000000000000000` 至 `0x00007fffffffffff`）
- **内核空间**（`0xffff800000000000` 至 `0xffffffffffffffff`）

这通过 **符号扩展** 位 63:48 实现，确保虚拟地址是 **规范的（canonical）**（即高位 16 位要么全为 0，要么全为 1）。

内核的内存布局定义在 `Documentation/x86/x86_64/mm.txt` 中，包括：

- 物理内存的直接映射
- `vmalloc` 和 `ioremap` 区域
- 内核文本段和模块映射
- KASAN 影子内存
- `vsyscall` 和 `fixup` 栈

---

## 结论

分页机制是 Linux 内核高效管理内存的关键。本文解释了 **四级分页结构** 的组成、虚拟地址如何转换为物理地址，以及内核如何组织其虚拟内存空间。

虽然本文主要讲解了 **理论基础**，后续内容将探讨内核如何实际 **构建和管理** 这些结构。

---

## 参考资料

- [维基百科：分页机制](http://en.wikipedia.org/wiki/Paging)
- [Intel 64 与 IA-32 架构软件开发手册](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)
- [Linux 内核文档 - x86_64 内存映射](https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt)
- [ELF64 格式说明](https://github.com/0xAX/linux-insides/blob/master/Theory/ELF.md)

---

> **注意：** 本文基于 0xAX 的原始文章撰写。英文并非作者的母语，欢迎通过 [linux-insides](https://github.com/0xAX/linux-insides) 仓库提交 Pull Request 来进行更正或改进。

.. SPDX-License-Identifier: GPL-2.0
.. include:: ../disclaimer-zh_CN.rst